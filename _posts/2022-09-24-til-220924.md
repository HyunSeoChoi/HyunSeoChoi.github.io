---
layout: post
title: TIL_220924
categories: [노트, TIL]
tags: [TIL]
author: hyunseo
img_path: /assets/img/posts/2022-09-24-til-220924/
---

아침에 호박죽을 먹고 뚝섬 유원지에 갔다. 자벌레 카페에서 동기들과 5시까지 공부하다가 배 위에 있는 깜닭치킨에서 치맥을 했다.

아래는 오늘 공부한 데이터 구조 정리본이다.

# 데이터 구조

## Programming in C++

- C에서 업그레이드된 버전
- 더 나은 절차 및 모듈성 프로그래밍 지원
- 데이터 추상화(새로운 데이터 타입 정의 가능)
- 객체 지향 프로그래밍 언어(계층 구조)

**Reference vs Pointers**

![6CC09370-762D-4D10-B93B-924C30C6C375.jpeg](6CC09370-762D-4D10-B93B-924C30C6C375.jpeg){: .shadow width="1548" height="864" style="max-width: 90%" }

레퍼런스는 선언과 동시에 초기화해야 한다. Null 초기화는 불가능하다. 또한 레퍼런스는 포인터와 다르게 메모리를 참조하고 별칭만 붙여주는 것이므로 메모리를 소모하지 않는다.

**네임 맹글링**

```cpp
extern "C" double sqrt(double);
extern void f();
```

개발자가 작성한 함수나 변수의 이름을 사용할 때 기존에 불러온 코드 파일에서 동일한 함수명을 사용했을 수 있기 때문에 구분짓기 위해 사용한다.

**Initialization and Cleanup**

- 클래스 생성과 할당 해제
- 연산자 오버로딩
- 클래스 템플릿(범용성 확대)
- 오류 핸들링(try… catch)
- 상속(부모 클래스, 자식 클래스)
- 접근 제어자
  - Public: 공개, 다른 클래스에서 접근 가능
  - Private: 변수가 속한 클래스 멤버 함수에서만 접근 가능
  - Friend: 특정 객체 멤버에 접근 가능(비선호)
  - Protected: 같은 클래스 & 자식 클래스에서 접근 가능

## Program Performance

초점은 ‘메모리’와 ‘시간’, 분석과 측정을 통해 결정한다.

**Space**

점유 중인 메모리양, 보통 바이트로 계산한다.

- 공간복잡도: 프로세스를 완료하는 데 필요란 메모리양
  - 필요성
    - 대규모 서비스일수록 공간 할당에는 한계가 있음
    - 컴퓨터에 충분한 메모리가 없을 수 있음
    - 필요한 공간이 다른 여러 솔루션이 있을 수 있음
    - 프로그램이 처리할 수 있는 데이터의 한계량을 예측할 수 있음
  - Program space = Instruction space + data space + stack space
    - Instruction space: 코드를 기계 언어로 번역하는 컴파일러 및 옵션 저장 공간.
    - Data space: 컴퓨터 아키텍처와 컴파일러에 따라 영향을 많이 받음. 변수와 상수 저장 공간. 되도록 작은 바이트를 차지하는 데이터 타입을 사용할 것. 배열을 사용할 때는 올바른 데이터 타입을 선택해야 함.
    - Environment Stack Space: 함수가 호출될 때마다, 리턴 주소, 지역 변수 및 Formal Parameter(매개변수). 또는 일부 레퍼런스를 저장하는 공간.
      - - 이러한 이유로 재귀 함수를 사용하는 것은 이 Environment Stack Space를 기하급수적으로 점유할 가능성이 있으므로 조심해야 함.
  - 공간을 효율적으로 사용하기 위하여…
    - 항상 더 작은 Suitable한 데이터 타입 선택.
    - 컴파일러 공부.
    - 되도록 비재귀 알고리즘 사용.

**Time**

프로그램 실행 시간

- 시간복잡도: 프로그램이 작업을 완수할 때까지 걸리는 컴퓨터 시간.

  - 필요성
    - 일부 컴퓨터는 한 프로그램을 돌릴 수 있는 시간에 한계가 있음. 알고리즘 문제를 풀거나, 서버를 임대했을 때 이러한 한계성이 두드러짐.
    - 실시간 응답을 필요로 하는 서비스가 많음.
    - 다양한 솔루션이 있을 때 보통 빠른 솔루션을 택함.
  - 측정 방법

    ![0E44FBC0-F6AD-4179-A3AC-EABCB031CF98.jpeg](0E44FBC0-F6AD-4179-A3AC-EABCB031CF98.jpeg){: .shadow width="1548" height="864" style="max-width: 90%" }

    - 개별 계산(작동) 측정(operation counts)
      - 단점: 선택한 작업 외 다른 요소 시간 측정X
        ![847A1D40-D2F2-4453-AF7C-696048B9EBD3.jpeg](847A1D40-D2F2-4453-AF7C-696048B9EBD3.jpeg){: .shadow width="1548" height="864" style="max-width: 90%" }
    - 스텝 개수 측정(step counts)
      - 모든 작업 파트의 시간을 측정함. 의미 있는 구문에 시간을 부여한다. 덧셈은 기록하지 않고 곱셈을 한 스텝으로 계산한다.
        [Step Count Method in Algorithm](https://www.tutorialspoint.com/step-count-method-in-algorithm)
        ![AA730020-B802-4401-8716-11F5AAF9EEC5.jpeg](AA730020-B802-4401-8716-11F5AAF9EEC5.jpeg){: .shadow width="1548" height="864" style="max-width: 90%" }
    - 점근선 측정(asymptotic)
      - 이전 방법(operation, step)의 한계
        - 변수(n)에 따른 growth를 계산할 수 있고 대략 시간 복잡도를 계산하여 솔루션 호율성 비교 가능 그러나 여전히 ‘정확한’ 측정 방법이 아님.
        - Operation counts는 핵심 작업에 초점을 두고, Step counts는 유의미한 구문을 구분하는 게 사실상 불가능에 가까움. 예를 들어 i = 3과 i = i + 3 \* 3을 같은 가중치로 봐야 하나?
      - Asymptotic은 시간/공간복잡도에 대해 유의미한 정보를 제공함. 시간복잡도가 n^2 + n vs 4n이더라도 항상 후자가 빠른 것이 아님(c는 상수). 위 예시에서 n이 1이면 후자가 더 빠름.
      - 따라서 N이 매우 큰 숫자라고 가정하고 여러 표기법을 소개한다.
        - 배경 지식
          - 시간복잡도 T(n)는 문제 크기가 n인 함수. 알고리즘 작동 스텝 수임.
          - Average case - 랜덤하게 입력해주었을 때 평균 스텝 수.
        - Big Oh (O): Upper bound.
          - 상한 점근. 내가 2018년에 작성한 시간복잡도에 관한 글을 후첨함. 프로그램이 아무리 나빠도 이 정도는 나온다.
          - f(n) = O(g(n)) (read as “f(n) is Big Oh of g(n)”)
          - 버블정렬의 시간복잡도는 O(n^2)이다. O(1)는 상수 시간에 풀 수 있는, O(n)는 선형적으로 시간이 증가하는, O(n^k)는 polynomially(높은 차수)하게 성장하는 복잡도다.
            [현서 lab : 네이버 블로그](https://blog.naver.com/arenaofjagal/221408220087)
        - Omega (Ω): Lower bound.
          - 하한 점근. 한 솔루션에 대한 알고리즘을 더 발견했을 때 어떤 알고리즘이 더 빠른지 구분할 때 사용할 수 있다. 어떤 한 알고리즘이 문제를 해결하는 데 실행시켜야 할 **최소 횟수**를 구한다. 프로그램이 아무리 좋아도 이 정도가 최대다.
          - 예를 들어 어떤 배열을 정렬하는 문제가 있을 때 요소들을 적어도 한 번씩은 확인해야 하므로 시간복잡도는 Ω(n)이 된다.
          - f(n) = Ω(g(n)) (read as “f(n) is omega of g(n)”)
            ![FEFCF755-A0BF-4C6D-9D3D-1316A3A2642E.jpeg](FEFCF755-A0BF-4C6D-9D3D-1316A3A2642E.jpeg){: .shadow width="1548" height="864" style="max-width: 90%" }
        - Theta (Θ): 알고리즘이 상하 경계가 생길 수 있을 때 활용한다.
          - f(n) = Q(g(n)) (read as “f(n) is theta of g(n)”)
          - 버블정렬은 하한 Ω(n), O(n^2)라서 c1g(n) ≤ f(n) ≤ c2g(n)를 만족하는 c1, c2, n0이 없다. 그러나 힙정렬의 경우에는 오메가와 빅 오 모두 n log n이다.
        - Little Oh (o): loose upper bound.

  - 시간복잡도 예시
    ![5F855B52-C714-42BF-81E1-EE106C8BA499.jpeg](5F855B52-C714-42BF-81E1-EE106C8BA499.jpeg){: .shadow width="1548" height="864" style="max-width: 90%" }
